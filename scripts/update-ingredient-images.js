/**
 * update-ingredient-images.js
 *
 * This script automates ingredient image management:
 * 1. Copies primary herb images from assets/herbs/ to assets/ingredients/
 * 2. Generates/updates the ingredientImageManifest.ts file
 * 3. Validates ingredientImageIds in free-recipes.json
 *
 * Usage: node scripts/update-ingredient-images.js
 *
 * Options:
 *   --dry-run    Show what would be done without making changes
 *   --validate   Only validate, don't copy or generate
 */

const fs = require('fs');
const path = require('path');

const HERBS_DIR = path.join(__dirname, '..', 'assets', 'herbs');
const INGREDIENTS_DIR = path.join(__dirname, '..', 'assets', 'ingredients');
const MANIFEST_PATH = path.join(__dirname, '..', 'src', 'assets', 'ingredientImageManifest.ts');
const RECIPES_PATH = path.join(__dirname, '..', 'src', 'data', 'free-recipes.json');

const args = process.argv.slice(2);
const isDryRun = args.includes('--dry-run');
const validateOnly = args.includes('--validate');

function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    if (isDryRun) {
      console.log(`[DRY-RUN] Would create directory: ${dirPath}`);
    } else {
      fs.mkdirSync(dirPath, { recursive: true });
      console.log(`Created directory: ${dirPath}`);
    }
  }
}

function getHerbImages() {
  if (!fs.existsSync(HERBS_DIR)) {
    console.error(`Herbs directory not found: ${HERBS_DIR}`);
    return [];
  }

  return fs.readdirSync(HERBS_DIR)
    .filter(file => /^\d+\.jpg$/i.test(file))
    .map(file => {
      const id = file.replace(/\.jpg$/i, '');
      return { id, filename: file };
    });
}

function getExistingIngredientImages() {
  if (!fs.existsSync(INGREDIENTS_DIR)) {
    return [];
  }

  return fs.readdirSync(INGREDIENTS_DIR)
    .filter(file => /\.jpg$/i.test(file))
    .map(file => {
      const id = file.replace(/\.jpg$/i, '');
      return { id, filename: file };
    });
}

function copyPrimaryHerbImages(herbImages) {
  ensureDir(INGREDIENTS_DIR);

  const copied = [];
  const skipped = [];

  for (const herb of herbImages) {
    const srcPath = path.join(HERBS_DIR, herb.filename);
    const destPath = path.join(INGREDIENTS_DIR, herb.filename);

    if (fs.existsSync(destPath)) {
      skipped.push(herb.id);
      continue;
    }

    if (isDryRun) {
      console.log(`[DRY-RUN] Would copy: ${herb.filename}`);
      copied.push(herb.id);
    } else {
      fs.copyFileSync(srcPath, destPath);
      copied.push(herb.id);
      console.log(`Copied: ${herb.filename}`);
    }
  }

  return { copied, skipped };
}

function generateManifest(ingredientImages) {
  const entries = ingredientImages
    .sort((a, b) => {
      const numA = parseInt(a.id, 10);
      const numB = parseInt(b.id, 10);
      if (!isNaN(numA) && !isNaN(numB)) {
        return numA - numB;
      }
      return a.id.localeCompare(b.id);
    })
    .map(img => `  '${img.id}': { source: require('../../assets/ingredients/${img.filename}'), imageId: '${img.id}' },`)
    .join('\n');

  const manifestContent = `import type { ImageSourcePropType } from 'react-native';

export type IngredientImageEntry = {
  source: ImageSourcePropType;
  imageId: string;
};

/**
 * Ingredient image manifest mapping image IDs to their require() sources.
 *
 * Naming convention:
 * - Primary ingredient images (from herbs): use recipe ID as the image ID (e.g., "1", "2", ...)
 * - Secondary/placeholder images: use "placeholder" or specific IDs like "2", "2-2", etc.
 *
 * The manifest is keyed by imageId (string) for flexibility.
 * Images are stored in assets/ingredients/.
 *
 * NOTE: This manifest is auto-generated by scripts/update-ingredient-images.js
 */
export const ingredientImageManifest: Record<string, IngredientImageEntry> = {
${entries}
};

/**
 * Fallback placeholder source when no image is available.
 * Returns null to indicate no image should be displayed.
 */
export const INGREDIENT_IMAGE_PLACEHOLDER: ImageSourcePropType | null = null;
`;

  return manifestContent;
}

function validateRecipeImageIds() {
  if (!fs.existsSync(RECIPES_PATH)) {
    console.error(`Recipes file not found: ${RECIPES_PATH}`);
    return { valid: false, errors: ['Recipes file not found'] };
  }

  const recipes = JSON.parse(fs.readFileSync(RECIPES_PATH, 'utf8'));
  const errors = [];
  const warnings = [];

  for (let i = 0; i < recipes.length; i++) {
    const recipe = recipes[i];
    const recipeId = i + 1;

    if (!recipe.ingredientImageIds) {
      errors.push(`Recipe ${recipeId} (${recipe.title}): missing ingredientImageIds`);
      continue;
    }

    if (!Array.isArray(recipe.ingredientImageIds)) {
      errors.push(`Recipe ${recipeId} (${recipe.title}): ingredientImageIds is not an array`);
      continue;
    }

    const ingredients = recipe.ingredients
      .split(',')
      .map(s => s.trim())
      .filter(Boolean);

    if (recipe.ingredientImageIds.length !== ingredients.length) {
      warnings.push(`Recipe ${recipeId} (${recipe.title}): ingredientImageIds length (${recipe.ingredientImageIds.length}) doesn't match ingredients count (${ingredients.length})`);
    }

    const firstImageId = recipe.ingredientImageIds[0];
    if (firstImageId !== String(recipeId)) {
      warnings.push(`Recipe ${recipeId} (${recipe.title}): first imageId is "${firstImageId}", expected "${recipeId}"`);
    }
  }

  return { valid: errors.length === 0, errors, warnings };
}

function main() {
  console.log('=== Ingredient Image Update Script ===\n');

  if (isDryRun) {
    console.log('[DRY-RUN MODE - No changes will be made]\n');
  }

  if (validateOnly) {
    console.log('[VALIDATE ONLY MODE]\n');
  }

  // Step 1: Get herb images
  console.log('Step 1: Scanning herb images...');
  const herbImages = getHerbImages();
  console.log(`Found ${herbImages.length} herb images (numbered .jpg files)\n`);

  if (!validateOnly) {
    // Step 2: Copy primary herb images to ingredients folder
    console.log('Step 2: Copying primary herb images to ingredients folder...');
    const { copied, skipped } = copyPrimaryHerbImages(herbImages);
    console.log(`Copied: ${copied.length}, Skipped (already exist): ${skipped.length}\n`);

    // Step 3: Get all ingredient images and generate manifest
    console.log('Step 3: Generating ingredient image manifest...');
    const ingredientImages = getExistingIngredientImages();
    console.log(`Found ${ingredientImages.length} ingredient images\n`);

    if (ingredientImages.length > 0) {
      const manifestContent = generateManifest(ingredientImages);

      if (isDryRun) {
        console.log('[DRY-RUN] Would write manifest with entries:');
        ingredientImages.forEach(img => console.log(`  - ${img.id}`));
      } else {
        fs.writeFileSync(MANIFEST_PATH, manifestContent);
        console.log(`Manifest written to: ${MANIFEST_PATH}`);
      }
    } else {
      console.log('No ingredient images found, manifest not updated.');
    }
  }

  // Step 4: Validate recipe ingredientImageIds
  console.log('\nStep 4: Validating recipe ingredientImageIds...');
  const validation = validateRecipeImageIds();

  if (validation.errors.length > 0) {
    console.log('\nErrors:');
    validation.errors.forEach(err => console.log(`  ❌ ${err}`));
  }

  if (validation.warnings.length > 0) {
    console.log('\nWarnings:');
    validation.warnings.forEach(warn => console.log(`  ⚠️  ${warn}`));
  }

  if (validation.valid && validation.warnings.length === 0) {
    console.log('✅ All recipe ingredientImageIds are valid!\n');
  } else if (validation.valid) {
    console.log(`\n✅ Validation passed with ${validation.warnings.length} warning(s)\n`);
  } else {
    console.log(`\n❌ Validation failed with ${validation.errors.length} error(s)\n`);
    process.exit(1);
  }

  console.log('=== Done ===');
}

main();
